<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
    canvas{
        background:#ccc;
    }
</style>
<script>
    window.onload=function(){
        var canvas=document.querySelector("canvas");
        var cobj=canvas.getContext("2d");
        var x=0;
        var y=0;
//        setInterval(function(){
//            cobj.clearRect(0,0,500,500);
//            x++;
//            y++;
//            cobj.fillRect(x,y,100,100);
//        },50)





//        setInterval(function(){
//            x++;
//            y++;
//            cobj.clearRect(0,0,500,500);
//            cobj.save();
//            cobj.translate(x,y);
//            cobj.fillRect(x,y,100,100);
//            cobj.restore();
//        },50);





      //  这种动画呢 translate属性是每次一移动它都会相对于原先的位置进行移动
//        setInterval(function(){
//            x++;
//            y++;
//            cobj.clearRect(0,0,500,500);
//            cobj.translate(x,y);
//            cobj.fillRect(x,y,100,100);
//        },50);



//         cobj.rotate(Math.PI/4);
//        cobj.translate(100,100);
//        cobj.fillRect(0,0,100,100);




//        cobj.translate(100,100);
//        cobj.rotate(Math.PI/4);
//        cobj.fillRect(0,0,100,100);

  //用面向对象的方式实现对多个图形的控制

//        function rect(){
//            this.x=0;
//            this.y=0;
//            this.w=100;
//            this.h=100;
//            this.color="#000";
//            this.speedx=10;
//            this.speedy=5;
//        }
//        rect.prototype={
//            draw:function(){
//                cobj.save();
//                cobj.translate(this.x,this.y);
//                cobj.fillStyle=this.color;
//                cobj.fillRect(0,0,this.w,this.h);
//                cobj.restore();
//            },
//            update:function(){
//                this.x+=this.speedx;
//                this.y+=this.speedy;
//            }
//        }
//        var rect1=new rect();
//        var rect2=new rect();
//        rect2.w=50;
//        rect2.h=50;
//        rect2.color="blue";
//        rect2.speedx=5;
//        rect2.speedy=10;
//        setInterval(function(){
//            cobj.clearRect(0,0,500,500);
//            rect1.draw();
//            rect1.update();
//            rect2.draw();
//            rect2.update();
//        },50)





        function arcle(){
            this.r=parseInt(15*Math.random());
            this.x=0;
            this.y=0;
            this.a=parseInt(500*Math.random());
            this.b=parseInt(500*Math.random());
            this.speedx=10-Math.random()*6;
            this.speedy=-7;
            this.zhongli=0.3;
            this.ruan=0.01;
            this.color="rgb("+parseInt(255*Math.random())+","+parseInt(255*Math.random())+","+parseInt(255*Math.random())+")";
        }


//        arcle.prototype={
//            draw:function(){
//                cobj.save();
//                cobj.beginPath();
//                cobj.fillStyle=this.color;
//                cobj.translate(this.x,this.y);
//                cobj.arc(this.a,this.b,this.r,0,2*Math.PI);
//                cobj.fill();
//                cobj.restore();
//
//            },
//            update:function(){
//                this.x+=this.speedx;
//                this.y+=this.speedy;
//                this.speedy+=this.zhongli;
//                this.r-=this.ruan;
//            }
//        }
//        var arr=[];
//        setInterval(function(){
//            cobj.clearRect(0,0,500,500);
//            arr.push(new arcle());
//            for(var i=0;i<arr.length;i++){
//                arr[i].draw();
//                arr[i].update();
//                if(arr[i].r<0){
//                    arr[i]=new arcle();
//                }
//            }
//            if(arr.length>200){
//                arr.shift();
//            }
//
//
//
//        },50)





//        var mx=0;
//        var my=0;
//        canvas.onmousemove=function(e){
//            mx= e.offsetX;
//            my= e.offsetY;
//        }
        function arcle(){
            this.r=parseInt(4*Math.random());
            this.x=0;
            this.y=0;
            this.a=250;
            this.b=250;
            this.speedy=1*Math.random();
            this.speedf=3*Math.random();
            this.ruan=0.01;
            this.color="rgb(226,17,12)";
            this.file=2;
            this.speedl=0.3;
        }


        arcle.prototype={
            draw:function(){
                cobj.save();
                cobj.beginPath();
                cobj.globalCompositeOperation="lighter";
                cobj.fillStyle=this.color;
                cobj.translate(this.x,this.y);
                cobj.arc(this.a,this.b,this.r,0,2*Math.PI);
                cobj.fill();
                cobj.restore();

            },
            update:function(){
                this.x+=4-Math.random()*2;
                this.y+=this.speedy;
                this.speedy+=this.speedf;
                this.r-=this.ruan;
                this.file-=this.speedl;
            }
        }
//        var arr=[];
//        setInterval(function(){
//            cobj.clearRect(0,0,500,500);
//            arr.push(new arcle());
//            for(var i=0;i<arr.length;i++){
//                arr[i].draw();
//                arr[i].update();
//                if(arr[i].r<0||arr[i].file<0){
//                    arr[i]=new arcle();
//                }
//            }
//            if(arr.length>200){
//                arr.shift();
//            }
//        },50)

        var arr=[];

        setInterval(function(){
            cobj.clearRect(0,0,500,500);
            arr.push(new arcle());
            for(var i=0;i<arr.length;i++){
                arr[i].draw();
                arr[i].update();
                if(arr[i].r<0||arr[i].file<0){
                   arr.splice(arr[i],1);
                }
            }
        },50)












    }
</script>
<body>
    <canvas width="500" height="500"></canvas>
</body>
</html>